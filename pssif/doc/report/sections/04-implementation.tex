\chapter{Implementation}
\label{chap:impl}

In the last chapter the conceptual approach to the realisation of the PSS-IF Proof-of-Concept was described. In particular, the latter sections of \chapref{chap:approach} describe the principles behind the chosen transformation method. In this context, this chapter focuses on the implementation of the framework. The chapter is structured as follows: \secref{sec:impl:technology} describes the technology stack used for the implementation. In the consequent \secref{sec:impl:principles} the adopted software development guiding principles are presented. Thereafter, \secref{sec:impl:structure} provides an overview of the project structure. \secref{sec:impl:components} follows with a description of each component of the PSS-IF PoC and, finally, \secref{sec:impl:process} describes the import and export processes and the collaboration of all components of the framework.

\section{Technology Stack}
\label{sec:impl:technology}

This section defines the technologies used for the implementation of the PSS-IF Proof-of-Concept. Each of the following subsections addresses a particular aspect of the technological stack. Note that all the software and tools used for the realization of the PoC are widely accepted industry standards.

\subsection{Programming Language}

To enable an easier and more rapid development of the prototype, a high-level programming language can better be utilized. Due to previous experience and know-how, the authors have chosen the Java Programming Language. Furthermore, the code is compliant with Java version 7, as distributed by Oracle. 

\subsection{Revision Control}

For improved parallelisation, better code maintenance and easier documentation, a distributed revision control can be used. While there are numerous alternatives, the authors have chosen GIT as a modern and powerful solution.

\subsection{Build Process and Dependency Management}

For the automated build process, as well as for the management of dependencies to external libraries, Apache Maven has been used.

\subsection{Test Framework}

For the execution of automated tests, JUnit, an industry standard framework, has been used.

\subsection{Used Libraries}

Next to the libraries provided by Oracle's Standard Java Runtime Environment, the following additional libraries have been used:

\paragraph{apache-compress} An API for the manipulation of different kinds of compressed files. In the scope of the Proof-of-Concept, the API is used in the Visio VSDX processing component, for the zipping and unzipping of VSDX files.

\paragraph{guava} Google Guava is a set of common libraries, mainly developed by Google. The package includes useful APIs for the manipulation of collections, the usage of function and predicates, and others.

\paragraph{junit} JUnit is an industry standard unit-testing framework.

\section{Guiding Principles}
\label{sec:impl:principles}

During the design and implementation of the PSS-IF PoC the authors have followed the principles and best-practices for software development. Some of the guiding principles were the following:

\paragraph{Standardization:} Usage of widely used and accepted industry-standard tools, technologies and formats, to render the produced solution more accessible to new developers and compliant to other pieces of software.

\paragraph{Patterns:} To maximize code quality and understandability, common architecture and design patterns have been utilized.

\paragraph{Object-Orientation:} The code is developed in accordance with the paradigms of the Java programming language -- it is mostly object-oriented and imperative.

\paragraph{Separation of Concerns:} The implementation follows the separation of concerns paradigm.

\section{Project Structure}
\label{sec:impl:structure}

The PSS-IF PoC is developed as an Apache Maven project, further divided into a root project, called ''\textbf{pssif}'' and a number of sub-modules. The root project is used for the provision of common development and  build configuration, as for example the specification of common dependencies with a fixed version over all modules. This avoids redundancy and improves the manageability of the developed code. Each of the modules represents a component of the PSS-IF PoC architecture on a coarse level of abstraction. Note that while it is possible to establish a project with fine-grained Maven modularity, division in fine-grained modules would make it more difficult to capture the project structure. This is why the authors have tried to find a balance between capturing coarse-level architectural concepts through Maven modularization, while fine-grained modularization of components is achieved through the packaging mechanism of the Java programming language.

This section covers the coarse-grained separation realized through Maven modularization, while \secref{sec:impl:components} is concerned with the fine-grained architectural modularization of the project. Currently, the PSS-IF PoC consists of four modules, as depicted in \color{red} TODO figref\color{black}.

\color{red} TODO screenshot of project strucutre\color{black}

\paragraph{Core} The ''\textbf{core}'' Maven module contains the fundamental Application Programming Interface (API) of the framework. This API defines the concepts through which the PSS-IF Domain-Specific Language (DSL) is described, such as Metamodel, Model, NodeTypes, Nodes etc. Furthermore, the core module provides an implementation layer for the concepts of the PSS-IF DSL, as well as a number of common utilities, like for example a generator for the canonic PSS-IF Metamodel, as depicted in \chapref{chap:intro}.

\paragraph{Transform} The ''\textbf{transformation}'' Maven module provides the Application Programming Interface (API) used for the definition and execution of transformations, as well as for input and output (I/O) operations. Next to the APIs, this module also contains their implementation, as well as a number of commonly used helping utilities, concerned with transformation or the serialization to or de-serialization from external formats. Finally, this module contains implementations for the supported source and target languages.

\paragraph{VSDX} The ''\textbf{vsdx}'' module is a dedicated module which provides an API and an implementation for the processing of Microsoft Visio 2013 VSDX documents. The module defines an abstraction layer describing the structure of a Visio document in an object-oriented fashion, and is used for the serialization and de-serialization of VSDX files.

\paragraph{SysML4Mechatronics} The ''\textbf{sysml4mechatronics}'' module contains a number of APIs and implementations for them, used for the serialization and de-serialization of SFB769 SysML4Mechatronics files.

\section{Components}
\label{sec:impl:components}

After, in the last section, the coarse-level division of the PSS-IF PoC parts through Maven modules was presented, this section focuses on a more detailed overview of the fine-level architectural components of the tool. Each of the following subsections describes the function and structure of a specific component of the transformation framework PoC.

\subsection{Core}

The core is the central component of the framework and is responsible for the realization of key concepts, used for the definition and processing of transformations. The core encloses two major concepts -- those of a Metamodel and a Model, which were already presented in \chapref{chap:approach}. \color{red}TODO figref\color{black} presents a UML Class Diagram of the core.

\subsubsection{Metamodel}

The Metamodel is a concept which enables the users of the framework to define the structure of their data. In this sense, a Metamodel also defines, on the abstract syntax level, the language in which the elements of a PSS-IF Model are described. A parallel in the domain of the Extensible Markup Language (XML) are the XML Schema Definitions (XSD). In essence, a PSS-IF Metamodel is the schema definition in accordance with which a particular Model is created and processed.

A PSS-IF Metamodel captures a number of concepts. In particular, it consists of Node and Edge Types, i.e. elements which enable the user to define what kinds of nodes and edges their model can have, what kinds of features they may have, and how they may relate to each other. Furthermore, in the PSS-IF PoC, inheritance relations can be defined between both Node and Edge types.

\paragraph{Node Types}

Node Types are used for the description of the different kinds of nodes in a model and have a number of features. All Node Types are named and the name must be unique in the scope of all Node and Edge Types within a Metamodel. Furthermore, Node Types can have a number of attributes, and are connected to other Node Types over Edge Types, which can be both incoming and outgoing.

There are two categories of Node Types -- conventional ones and Junction Node Types. The latter are actually Node Types with edge semantics, i.e. they are used for the representation of hyper-edges.

\paragraph{Edge Types}

Edge Types are used for the description of possible edges in a user's model. Edge Types also have a name, which is unique in the scope of a Metamodel. For it to be possible to associate the same Edge Type with different pairs of Node Types, the concept of Connection Mappings is used. A Connection Mapping is an association assigned to a particular Edge Type, which includes an incoming and an outgoing Note Type.

To illustrate the usage of the Connection Mappings, consider the following example: Assuming two Node Types, denoted ''State'' and ''Function'' and an Edge Type ''Control Flow'', which has to connect both Node Types in both directions. In the PSS-IF PoC this is achieved by defining a single Edge Type ''Control Flow'' and assigning two Connection Mappings to it: one from ''State'' to ''Function'' and one from ''Function'' to ''State''.

\paragraph{Attributes}

For both Node and Edge Types, Attributes can be defined. Attributes are divided into Attribugte Groups, which can be used to separate different kinds of attributes conveniently, for example in a user interface. Furthermore, Attributes are identified by their names, which have to be unique in the scope of the owning Node or Edge Type. Also, each attribute has a Data Type. The PSS-IF PoC defines a number of primitive data types, like String, Integer, Date and Boolean, and also provides the user with the ability to define custom enumeration data types. Finally, Attributes can optionally have a Unit associated with them, which can be particularly useful for numeric Attributes. Finally, Attributes are divided into categories. Currently, the following categories are defined: Monetary, Weight, Density, Time, Geometry, MetaData and Material.

\paragraph{Inheritance}

As already noted above, for both Node and Edge Types, inheritance relations can be defined. When a Node Type inherits from another Node Type, it holds that Attribute Groups and Attributes are inherited from the parent. With Edge Types, inheritance is slightly more complex. For Attributes, the same rule holds as for Node Types. Connection Mappings are generally not inherited. Nonetheless, when extracting the instances of a Node or Edge Type from a Model, the user can specify whether instances of the specializations of this Node or Edge Type should be included in the result set. \color{red}TODO more detail, better formulation \color{black}.

\paragraph{Built-In Metamodel Elements}

Every PSS-IF Metamodel has a number of predefined elements. These are the root Node and Edge Types. The root node type has the name ''Node'' and provides the following predefined Attributes:

\begin{itemize}
\item \textbf{id}: An identifier with data type String for the node instance of the node type, categorized as Metadata.
\item \textbf{name}: A name with data type String, categorized as Metadata.
\item \textbf{validity start}: A Date, designating the begin of the validity period of the given node, categorized as Time.
\item \textbf{validity end}: A Date, designating the end of the validity period of the given node, categorized as Time.
\item \textbf{version}: The version of the node, of data type String, categorized as Metadata.
\item \textbf{comment}: A comment of the node, of data type String, categorized as Metadata.
\end{itemize}

The root Edge Type ''Edge'' has all built-in Attributes defined for the root Node Type ''Node'', and also an additional Attribute \textbf{directed} of data type Boolean and categorized as Metadata. 

The root Node and Edge Types are also the roots of the inheritance hierarchies for Node and Edge Types within a Metamodel. In this sense, any Node or Edge Type automatically inherits from the root Node or Edge Type, accordingly. Thus, it is guaranteed that the set of Attributes provided above is automatically defined for all Node and Edge Types. If a Node or Edge Type inherits from a non-root Node or Edge Type, the Attributes are inherited transitively, together with all Attributes of all ancestors throughout the generalization closure.

\subsubsection{Model}

TODO simple and dumb. all is done through mm -- this is soo cool, because it provides for security and data integrity...

\subsection{Transformations}

TODO

\subsection{Generic Graph}

TODO

\subsection{I/O Mappers}

TODO

\subsection{Model Mappers}

TODO

\subsection{Microsoft Visio VSDX I/O}

TODO

\section{Import and Export Process}
\label{sec:impl:process}

TODO describe process, mit TEXT und BILD! 

\begin{itemize}
\item technology: java. maven... expplain why
\item guiding principles of development
\item project structure
\item core
\item transform
\item vsdx
\item viz?
\end{itemize}